#!/bin/bash

usage () {
	echo "usage: mk-images <pkgsrc> <toplevel> <template> <buildarch>"
    exit 0
}

if [ -z "$1" -o -z "$2" -o -z "$3" -o -z "$4" ]; then usage; fi

TOPDIR=$(echo $0 | sed "s,/[^/]*$,,")
if [ $TOPDIR = $0 ]; then
    $TOPDIR="."
fi

TOPDIR=$(cd $TOPDIR; pwd)

# Set, verify, and create paths
    KERNELPATH=$1
    TOPDESTPATH=$2
    IMAGEPATH=$2/images
    FULLMODPATH=$2/RedHat/instimage/modules
    INSTIMGPATH=$2/RedHat/base
    INSTIMGTEMPLATE=$3
    IMGPATH=$2/RedHat/instimage
    KERNELROOT=/tmp/updboot.kernel.$$
    MODDEPS=$KERNELROOT/moddeps
    BUILDARCH=$4

    if [ ! -d "$1" ]; then
	LATEST=latest --arch $BUILDARCH
    else
	LATEST=findPackage
    fi

    rm -rf $IMAGEPATH
    rm -rf $FULLMODPATH
    rm -rf $KERNELROOT
    mkdir -p $IMAGEPATH
    mkdir -p $FULLMODPATH
    mkdir -p $KERNELROOT
    mkdir -p $INSTIMGPATH

# Stuff that we need
    TRIMPCITABLE=$IMGPATH/usr/lib/anaconda-runtime/trimpcitable
    KEYMAPS=$IMGPATH/usr/lib/anaconda-runtime/keymaps-${BUILDARCH}
    FONTS=$IMGPATH/usr/lib/anaconda-runtime/fonts-${BUILDARCH}
    GETMODDEPS=$IMGPATH/usr/lib/anaconda-runtime/moddeps
    MODLIST=$IMGPATH/usr/lib/anaconda-runtime/modlist
    MODINFO=$IMGPATH/usr/lib/anaconda-runtime/loader/module-info
    FILTERMODDEPS=$IMGPATH/usr/lib/anaconda-runtime/filtermoddeps
    LOADERBINDIR=$IMGPATH/usr/lib/anaconda-runtime/loader
    BOOTDISKDIR=$IMGPATH/usr/lib/anaconda-runtime/boot
    LANGTABLE=$IMGPATH/usr/lib/anaconda/lang-table
    PCITABLE=$IMGPATH/usr/share/kudzu/pcitable
    CACHE=$KERNELROOT/lib/modules/.cache
    MODULESUSED=$KERNELROOT/modules-used

    touch $MODULESUSED

    REQUIREMENTS="$TRIMPCITABLE $PCITABLE $GETMODDEPS $MODINFO
		  $FILTERMODDEPS $LANGTABLE $KEYMAPS"

    dieLater=
    for n in $REQUIREMENTS; do
	if [ ! -f $n ]; then
	    echo "$n doesn't exist"
	    dieLater=1
	fi
    done

    for n in $BOOTDISKDIR; do
	if [ ! -d $n ]; then
	    echo "$n doesn't exist"
	    dieLater=1
	fi
    done

    if [ -n "$dieLater" ]; then exit 1; fi

findPackage() {
    dir=$1
    name=$2
    
    for n in $dir/$name*; do
	thisName=$(rpm --qf '%{NAME}' -qp $n)
	if [ -z "$thisName" ]; then
	    return
	fi
	if [ $thisName = $name ]; then
	    echo $n
	    return
	fi
    done

    echo "cannot find package $name in path $dir" >&2
    kill -9 $$
}

findmodule () {
    if [ ! -f $CACHE ]; then
        find $KERNELROOT/lib/modules > $CACHE
    fi
    
    grep "/$1\.o" $CACHE
}

rundepmod () {
    what=$1
    final=$2

    exclpattern="tc90x|FPT|BusLogic|Pci2000|Pci2220i"

    depmod -e -i -m $KERNELROOT/boot/System.map-$version \
	    $what > $final.foo 2>&1 | 
	    egrep -v "modprobe: (${exclpattern}) multiply defined"

    PARIDE="aten bpck comm dstr epat epia fit2 fit3 friq frpw kbic ktti on20 on26"
    cat $final.foo | sed -e 's/\.o//g' \
	  -e 's/: parport$/: parport_pc/g' \
	  -e 's/^\(parport_pc: parport\)_pc$/\1/' \
	  -e "s/^pcd:.*/pcd: $PARIDE/" | $FILTERMODDEPS > $final 
    rm -f $final.foo
}

getmoddeps () {
    what=$1
    final=$2

    egrep $(echo $what | sed 's/\.o  */|^/g;s/\.o$//') $MODDEPS > $final
}

intcopymodules () {
    dir=$2

    for n in $1; do
	m=$(findmodule $n)
	if [ -z "$m" ]; then
            echo "Module $n not found in kernel rpm"
        else 
	    echo $n >> $MODULESUSED
	    if ! cp $m $dir ; then
		echo "Failed to copy $m to $dir (for module $n)"
	    fi
        fi
    done
}

resdeps () {
    $GETMODDEPS -m $MODDEPS $* 2>&1
    if [ $? != "0" ] ; then
	kill -9 $$
    fi	
    list=`$GETMODDEPS -m $MODDEPS $*`
    items=$(for n in $* $list; do echo $n; done | sort -u)
    echo $items
}

expandModuleSet() {
    SET=""
    for name in $1; do
	char=$(echo $name | cut -c1)
        if [ $char = '=' ]; then
	    NAME=$(echo $name | cut -c2-)
	    SET="$SET $($MODLIST --modinfo-file $MODINFO $NAME)"
	elif [ $char = '+' ]; then
	    NAME=$(echo $name | cut -c2-)

	    # all of the modules of this type
	    $MODLIST --modinfo-file $MODINFO $NAME > /tmp/emsAll.$$
	    # the modules used that are of this type
	    cat $MODULESUSED /tmp/emsAll.$$ | sort | uniq -d > /tmp/emsUsed.$$
	    # the modules that are of this type, but not used
	    SET=$(cat /tmp/emsAll.$$ /tmp/emsUsed.$$ | sort | uniq -u)

	    rm -f /tmp/emsAll.$$ /tmp/emsUsed.$$
	else
	    SET="$SET $name"
	fi
    done

    echo $SET
}

makemoduleball() {
    unset MMB_DD
    MMB_MODINFO="module-info"

    if [ "$1" = "--dd" ]; then
        MMB_DD="$2"
	shift; shift
	MMB_MODINFO="modinfo"
    fi

    MMB_DIR=$1
    MMB_MODULESET=$(resdeps $2)

    rm -rf $MMB_DIR/modules $MMB_DIR/modules.cgz $MMB_DIR/modules.dep \
	   $MMB_DIR/pcitable $MMB_DIR/$MMB_MODINFO
    mkdir -p $MMB_DIR/modules

    intcopymodules "$MMB_MODULESET" $MMB_DIR/modules

    pushd $MMB_DIR/modules > /dev/null

    $MODLIST --modinfo-file $MODINFO --ignore-missing --modinfo \
	$MMB_MODULESET > ../$MMB_MODINFO

    getmoddeps "*.o" ../modules.dep

    # create the pcitable
    $TRIMPCITABLE *.o < $PCITABLE > ../pcitable

    if [ -n "$MMB_DD" ]; then
	echo $MMB_DD > $MMB_DIR/rhdd-6.1
    fi

    mkdir $version
    mv *.o $version

    find $version -type f | cpio --quiet -H crc -o | gzip -9 > ../modules.cgz
    cd ..
    rm -rf modules
    popd  > /dev/null
}

makemainmodules() {
    modlist=`expandModuleSet "$1"`

    rm -rf $FULLMODPATH

    makemoduleball $FULLMODPATH "$modlist"
}

makeinitrd() {
    EXTRAINITRDPATH=""
    PCMCIA=""
    INITRDSIZE=""
    KEEP=""
    PADSIZE=""
    LOADERBIN=""
    INITRDMODULES=""
    while [ x$(echo $1 | cut -c1-2) = x"--" ]; do
	if [ $1 = "--initrdto" ]; then
	    EXTRAINITRDPATH=$2
	    shift; shift
	    continue
	elif [ $1 = "--pcmcia" ]; then
	    PCMCIA=yes
	    shift
	    continue
	elif [ $1 = "--keep" ]; then
	    KEEP=yes
	    shift
	    continue
	elif [ $1 = "--initrdsize" ]; then
	    INITRDSIZE=$2
	    shift; shift
	    continue
	elif [ $1 = "--padsize" ]; then
	    PADSIZE=$2
	    shift; shift
	    continue
	elif [ $1 = "--loaderbin" ]; then
	    LOADERBIN=$2
	    shift; shift
	    continue
	elif [ $1 = "--modules" ]; then
	    LOADERMODULES=$2
	    shift; shift
	    continue
	fi
	echo "Unknown option passed to makeinitrd"
	exit 1
    done
    if [ -z "$LOADERBIN" ]; then
	echo "no loader binary specified!" >&2
	exit 1
    fi
    if [ -z "$LOADERMODULES" ]; then
	echo "no loader modules specified!" >&2
	exit 1
    fi
    if [ -z "$INITRDSIZE" ]; then
	echo "I don't know how big to make the initrd image!" >&2
	exit 1
    fi

    MODSET=`expandModuleSet "$LOADERMODULES"`
    MBD_DIR=/tmp/makebootdisk.dir.$$
    MBD_FSIMAGE=/tmp/makebootdisk.initrdimage.$$
    MBD_MNTPOINT=/tmp/makebootdisk.mount.$$
    MBD_TMPIMAGE=/tmp/makebootdisk.image.$$
    MBD_BOOTTREE=/tmp/makebootdisk.tree.$$
    INITBIN=init

    rm -rf $MBD_DIR MBD_FSIMAGE
    mkdir -p $MBD_DIR/modules
    mkdir -p $MBD_DIR/sbin
    mkdir -p $MBD_DIR/dev/pts
    mkdir -p $MBD_DIR/etc
    mkdir -p $MBD_DIR/proc
    mkdir -p $MBD_DIR/tmp
    mkdir -p $MBD_DIR/etc/terminfo/l
    mkdir -p $MBD_DIR/var/state
    ln -s /tmp $MBD_DIR/var/state/xkb

    makemoduleball $MBD_DIR/modules "$MODSET"

    cat > $MBD_DIR/etc/passwd << EOF
    root::0:0:root:/:/bin/bash
EOF

    install -s -m 755 $LOADERBINDIR/$LOADERBIN $MBD_DIR/sbin/loader
    install -s -m 755 $LOADERBINDIR/$INITBIN $MBD_DIR/sbin
    install -m 644 $KEYMAPS $MBD_DIR/etc/keymaps.gz
    install -m 644 $FONTS $MBD_DIR/etc/fonts.cgz
    install -m 644 $LANGTABLE $MBD_DIR/etc
    install -m 644 $LANGTABLE $LOADERBINDIR/loader.tr $MBD_DIR/etc
    install -m 644 /usr/share/terminfo/l/linux $MBD_DIR/etc/terminfo/l/linux

    if [ -n "$PCMCIA" ]; then
	mkdir -p $MBD_BOOTTREE/etc
	cp -a $KERNELROOT/etc/pcmcia $MBD_DIR/etc
    fi

    for n in insmod rmmod modprobe; do
	ln -s loader $MBD_DIR/sbin/$n
    done

    ln -s /usr/bin/sh $MBD_DIR/sbin/sh
    ln -s /sbin/init $MBD_DIR/linuxrc
    ln -s /proc/mounts $MBD_DIR/etc/mtab
    ln -s sbin $MBD_DIR/bin

    # FIXME: keymaps?
    # FIXME: fonts?

    awk '{ printf("mknod %s/dev/%s %s %s %s\n", $1, $2, $3, $4, $5);
	   printf("chmod %s %s/dev/%s\n", $6, $1, $2);
	   printf("chown %s %s/dev/%s\n", $7, $1, $2); 
	 }' <<EOF | sh
	$MBD_DIR console c 5 1 600 root:root
	$MBD_DIR ttyS0 c 4 64 600 root:root
	$MBD_DIR ttyS1 c 4 65 600 root:root
	$MBD_DIR ttyS2 c 4 66 600 root:root
	$MBD_DIR ttyS3 c 4 67 600 root:root
	$MBD_DIR psaux c 10 1 644 root:root
	$MBD_DIR null c 1 3 666 root:root
	$MBD_DIR zero c 1 5 666 root:root
	$MBD_DIR md0 b 9 0 644 root:root
	$MBD_DIR mem c 1 1 600 root:root
	$MBD_DIR ram b 1 1 640 root:root
	$MBD_DIR ptmx c 5 2 666 root:root
	$MBD_DIR tty0 c 4 0 600 root:tty
	$MBD_DIR tty1 c 4 1 600 root:tty
	$MBD_DIR tty2 c 4 2 600 root:tty
	$MBD_DIR tty3 c 4 3 600 root:tty
	$MBD_DIR tty4 c 4 4 600 root:tty
	$MBD_DIR tty5 c 4 5 600 root:tty
	$MBD_DIR tty6 c 4 6 600 root:tty
	$MBD_DIR tty7 c 4 7 600 root:tty
EOF

cat > $MBD_DIR/.profile <<EOF
PATH=/bin:/usr/bin:/usr/sbin:/usr/X11R6/bin:/mnt/sbin:/mnt/usr/sbin:/mnt/bin:/mnt/usr/bin
export PATH
EOF

    rm -f $MBD_FSIMAGE
    dd if=/dev/zero of=$MBD_FSIMAGE bs=1k count=$INITRDSIZE 2> /dev/null
    echo y | /sbin/mke2fs -i 8096 -q $MBD_FSIMAGE $INITRDSIZE > /dev/null 2>/dev/null

    rm -rf $MBD_MNTPOINT
    mkdir $MBD_MNTPOINT
    mount -o loop -t ext2 $MBD_FSIMAGE $MBD_MNTPOINT
    (cd $MBD_DIR; find . | cpio --quiet -p $MBD_MNTPOINT)

    left=$(df $MBD_MNTPOINT | tail +2)
    left=$(echo $left | awk '{print $4'})

    umount $MBD_MNTPOINT

    echo "Wrote initrd.img (${left}k free)"

    mv -f $MBD_FSIMAGE $MBD_FSIMAGE.uncompressed
    gzip -9 < $MBD_FSIMAGE.uncompressed > $MBD_FSIMAGE
    rm -rf $MBD_FSIMAGE.uncompressed $MBD_DIR

    rm -rf $MBD_TMPIMAGE $MBD_BOOTTREE

    if [ -n "$PADSIZE" ]; then
	size=`cat $MBD_FSIMAGE | wc -c`
	filler=`expr $PADSIZE "*" 1024 - $size`
	dd if=/dev/zero bs=$filler count=1 >> $MBD_FSIMAGE 2> /dev/null
    fi

    if [ -n "$EXTRAINITRDPATH" ]; then
	mkdir -p `dirname $EXTRAINITRDPATH`
	cp -a $MBD_FSIMAGE $EXTRAINITRDPATH
    fi

    if [ -z "$KEEP" ]; then
	rm -rf $MBD_TMPIMAGE $MBD_FSIMAGE $MBD_MNTPOINT $MBD_BOOTTREE
    fi
}

makebootdisk() {
    BOOTDISKSIZE=""
    EXTRAKERNELPATH=""
    INITRDFLAGS=""
    MBD_FILENAME=""
    while [ x$(echo $1 | cut -c1-2) = x"--" ]; do
	if [ $1 = "--bootdisksize" ]; then
	     BOOTDISKSIZE=$2
	     shift; shift
	     continue
	elif [ $1 = "--kernelto" ]; then
	    EXTRAKERNELPATH=$2
	    shift; shift
	    continue
	elif [ $1 = "--initrdflags" ]; then
	    INITRDFLAGS=$2
	    shift; shift
	    continue
	elif [ $1 = "--imagename" ]; then
	    MBD_FILENAME=$IMAGEPATH/$2
	    shift; shift
	    continue
	fi
	echo "Unknown option passed to makebootdisk"
	exit 1
    done

    if [ -z "$MBD_FILENAME" ]; then
	echo "No imagename passed"
	exit 1
    fi

    if [ ! -z "$INITRDFLAGS" ]; then
	eval makeinitrd --keep $INITRDFLAGS
    fi

    mkdir -p $MBD_BOOTTREE

    # provided by the mk-image.$ARCH file
    prepareBootImage

    left=$(df $MBD_BOOTTREE | tail +2)
    left=$(echo $left | awk '{print $4'})

    umount $MBD_BOOTTREE

    if [ -n "$EXTRAKERNELPATH" ]; then
	mkdir -p `dirname $EXTRAKERNELPATH`
	cp -a $KERNELROOT/boot/vmlinuz-* $EXTRAKERNELPATH
    fi

    rm -f $MBD_FILENAME
    mv -f $MBD_TMPIMAGE $MBD_FILENAME
    rm -rf $MBD_TMPIMAGE $MBD_FSIMAGE $MBD_MNTPOINT $MBD_BOOTTREE

    echo "Wrote $MBD_FILENAME (${left}k free)"
}

makeImage () {
    MI_FROM=$1
    MI_SIZE=$2
    MI_TO=$3
    MI_TMPIMAGE=/tmp/makeimage.img.$$
    MI_MNTPOINT=/tmp/makeimage.mnt.$$

    mkdir -p $MI_MNTPOINT

    dd if=/dev/zero of=$MI_TMPIMAGE bs=1k count=$MI_SIZE 2>/dev/null
    echo y | /sbin/mke2fs -i 4096 $MI_TMPIMAGE  > /dev/null 2>/dev/null
    mount -o loop $MI_TMPIMAGE $MI_MNTPOINT
    (cd $MI_FROM; find . | cpio --quiet -p $MI_MNTPOINT)

    left=$(df $MI_MNTPOINT | tail +2)
    left=$(echo $left | awk '{print $4'})

    umount $MI_MNTPOINT
    rmdir $MI_MNTPOINT

    gzip -9 < $MI_TMPIMAGE > $MI_TO

    echo "Wrote $MI_TO (${left}k of ${MI_SIZE}k free)"
}

makeinstimage () {
    SIZE1=4096
    SIZE2=""

    while [ $(echo $1 | cut -c1-2) = "--" ]; do
	if [ $1 = "--size1" ]; then
	    SIZE1=$2
	    shift; shift
	elif [ $1 = "--size2" ]; then
	    SIZE2=$2
	    shift; shift
	fi
    done

    imagename=$1
    modlist=$(expandModuleSet "$2")
    tmpdir=/tmp/instimage.dir.$$

    rm -rf $tmpimage $tmpdir
    mkdir -p $mntpoint $tmpdir

    mkdir -p $tmpdir
    (cd $INSTIMGTEMPLATE; find . | cpio --quiet -p $tmpdir)
    makemoduleball $tmpdir/modules "$modlist"

    if [ -n "$SIZE2" ]; then
	makeImage $tmpdir/usr $SIZE2 $INSTIMGPATH/${imagename}2.img
	rm -rf $tmpdir/usr
    fi

    makeImage $tmpdir $SIZE1 $INSTIMGPATH/${imagename}1.img
    rm -rf $tmpdir
}

makemainimage () {
    imagename=$1
    tmpimage=/tmp/instimage.img.$$
    mntpoint=/tmp/instimage.mnt.$$

    rm -rf $mntpoint $tmpimage
    mkdir $mntpoint

    SIZE=$(du -sk $IMGPATH | awk '{print $1}')

    dd if=/dev/zero of=$tmpimage bs=1k count=$SIZE 2>/dev/null
    echo y | /sbin/mke2fs -m 0 -i 4096 $tmpimage  > /dev/null 2>/dev/null
    mount -o loop $tmpimage $mntpoint
    (cd $IMGPATH; find . | cpio --quiet -p $mntpoint)

    # Doing this on two lines keeps the df output from being broken apart
    left=$(df $mntpoint | tail +2)
    left=$(echo $left | awk '{print $4'})

    umount $mntpoint
    rmdir $mntpoint

    cp $tmpimage $INSTIMGPATH/${imagename}.img

    echo "Wrote $INSTIMGPATH/${imagename}.img (${left}k of ${SIZE}k free)"

    rm $tmpimage
}

makedriverdisk () {
    modlabel=$1
    diskname=$2
    modlist=$(expandModuleSet "$3")
    diskpath=/tmp/makedriverdisk.$$

    rm -rf $diskpath
    mkdir -p $diskpath

    makemoduleball --dd "$modlabel" $diskpath "$modlist"

    size=$(expr 60 + $(du -sk $diskpath | awk '{print $1}'))
    if [ $size -lt 57 ]; then
	size=64
    fi

    dd if=/dev/zero of=/tmp/$diskname.img bs=1k count=$size 2> /dev/null
    echo y | /sbin/mke2fs -i 4096 /tmp/$diskname.img  > /dev/null 2>/dev/null
    mkdir -p /tmp/mkdd.$$
    mount -t ext2 -o loop /tmp/$diskname.img /tmp/mkdd.$$
    rmdir /tmp/mkdd.$$/lost+found
    (cd $diskpath; tar cSpf - .) | (cd /tmp/mkdd.$$; tar xSpf -)
    DIE=""
    if [ $(du -s $diskpath | cut -f1) != $(du -s /tmp/mkdd.$$ | cut -f1) ]; then
	echo copy to disk image failed
	ls -l /tmp/mkdd.$$
	echo "disk size: $size"
	ls -l $diskpath
	DIE=1
    fi
    umount /tmp/mkdd.$$
    rm -rf /tmp/mkdd.$$

    if [ -n "$DIE" ]; then
	kill -9 $$
    fi

    cp /tmp/${diskname}.img $IMAGEPATH/${diskname}.img
    rm /tmp/${diskname}.img
    rm -rf $diskpath

    size=$(ls -l $IMAGEPATH/${diskname}.img | awk '{ print $5 }')
    size=$(expr $size / 1024)

    echo "Wrote $IMAGEPATH/${diskname}.img (${size}k)"
}

# Find the kernel, unpack it, and verify it
    kpackage=$($LATEST $KERNELPATH kernel-BOOT)
    ppackage=$($LATEST $KERNELPATH kernel-pcmcia-cs)
    version=$(rpm --qf '%{VERSION}-%{RELEASE}' -qp $kpackage)BOOT

    rpm2cpio $kpackage | (cd $KERNELROOT; cpio --quiet -iumd)
    if [ ! -z $ppackage ]; then 
	rpm2cpio $ppackage | (cd $KERNELROOT; cpio --quiet -iumd etc/pcmcia/*)
    fi

    if [ ! -d "$KERNELROOT/lib/modules/$version/scsi" ]; then
	echo "$1 is not a valid modules directory" 2>&1
	usage
    fi

    if [ ! -f "$KERNELROOT/boot/vmlinuz-$version" ]; then
	echo "$KERNELROOT/boot/vmlinuz-$version does not exist"
	usage
    fi

    if [ -d $KERNELROOT/lib/modules/$version/pcmcia ]; then
	PCMCIAMODULES=$(cd $KERNELROOT/lib/modules/$version/pcmcia; ls *.o |
	    sed 's/\.o//g')
    fi

    rundepmod "$KERNELROOT/lib/modules/$version/*/*.o" $MODDEPS
    rm -f $MODDEPS.foo

. $TOPDIR/mk-images.${BUILDARCH}

rm -rf $KERNELROOT
