#!/bin/bash
#
# upd-bootiso
#
# Copyright (C) 2010-2011  Red Hat, Inc.  All rights reserved.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Author: Brian C. Lane <bcl@redhat.com>
#
# Update an existing installer iso image with new anaconda rpm build
# This works for both the boot/netinstall and DVD .iso
#
# This likely only works with x86 iso's since doPostImages() was borrowed
# from mk-images.x86
#

# Borrowed from mk-images.x86
doPostImages() {
    if [ -n "$BOOTISO" ]; then
        EFIARGS=""
        EFIGRAFT=""
        if [ -f $TOPDESTPATH/images/efiboot.img ]; then
            echo "Found efiboot.img, making an EFI-capable boot.iso"
            EFIARGS="-eltorito-alt-boot -e images/efiboot.img -no-emul-boot"
            EFIGRAFT="EFI/BOOT=$TOPDESTPATH/EFI/BOOT"
        else
            echo "No efiboot.img found, making BIOS-only boot.iso"
        fi
        BIOSARGS="-b isolinux/isolinux.bin -c isolinux/boot.cat -no-emul-boot -boot-load-size 4 -boot-info-table"
        mkisocmd="mkisofs -v -o $BOOTISO $BIOSARGS $EFIARGS -R -J -V '$CDLABEL' -T $TOPDESTPATH"
        echo $PWD:\$ $mkisocmd
        eval $mkisocmd
        if [ -x /usr/bin/isohybrid ]; then
            isohybrid $BOOTISO || echo "Unable to make hybrid boot.iso"
        fi
        implantisomd5 $BOOTISO
    fi
}

abspath() {
    dir="$1"
    file=""
    if [[ -f "$dir" ]]; then
        file=/`basename "$dir"`
        dir=`dirname "$dir"`
    fi
    echo `cd "$dir" && pwd -P`"$file"
}

unpackRPMs() {
    # Unpack the rpm's files into the tree
    rpm2cpio $ANACONDA_RPM | cpio -idu

    # Unpack any other rpms
    for f in $EXTRA_RPMS; do
        echo "Unpacking $f"
        rpm2cpio $f | cpio -idu
    done
}

uncompressInitrd() {
    echo "Extracting the initrd.img to ./newinitrd"
    mkdir ./newinitrd
    pushd ./newinitrd
    if [ $1 -gt 14 ]; then
        unxz < ../newiso/isolinux/initrd.img | cpio -idu
    else
        gunzip < ../newiso/isolinux/initrd.img | cpio -idu
    fi
    popd
}


usage() {
        if [ $1 -ne 0 ]; then
                >&2
        fi
        echo "upd-bootiso [--shell] [--skipiso] [--leavetmp] [--dest /tmp] <boot.iso> <anaconda.rpm> [other.rpm] [...]"
        echo "            --shell       Run a shell before rebuilding the iso"
        echo "            --skipiso     Skip creating the final iso"
        echo "            --leavetmp    Don't cleanup the /tmp/tmp.* directory"
        echo "            --dest /tmp   Destination directory for final iso or image files"
        exit $1
}

[ "$1" == "--help" ] && usage 0

DEST="/tmp/"
RUNSHELL=0
SKIPISO=0
LEAVETMP=0
while [ $# -gt 0 ]; do
    case $1 in
        --shell)
            RUNSHELL=1
            shift
        ;;
        --skipiso)
            SKIPISO=1
            shift
        ;;
        --leavetmp)
            LEAVETMP=1
            shift
        ;;
        --dest)
            DEST=$(abspath $2)
            shift; shift
        ;;
        *)
            if [ -z "$ORIG_ISO" ]; then
                ORIG_ISO=$(abspath $1)
            elif [ -z "$ANACONDA_RPM" ]; then
                ANACONDA_RPM=$(abspath $1)
            else
                EXTRA_RPMS="$EXTRA_RPMS$(abspath $1) "
            fi
            shift
        ;;
    esac
done

[ -z "$ORIG_ISO" -o -z "$ANACONDA_RPM" ] && usage 1

# Which anaconda release is this?
echo $ANACONDA_RPM | python -c 'import sys,os;exit(int(os.path.basename(sys.stdin.readline())[9:].split(".")[0]))'
VER=$?
echo "VERSION is $VER"

# Figure out if this is a 64 bit system
# < 12 doesn't use lib64 directory
if [[ $VER -gt 11 && $ANACONDA_RPM =~ "x86_64" ]]; then
    LIBDIR=lib64
else
    LIBDIR=lib
fi
echo "LIBDIR=$LIBDIR"

if [ "$(id -u)" != "0" ]; then
   echo "You must be root to run this script"
   exit 1
fi

TMPDIR=$(mktemp -d)
[ $? -eq 0 ] || exit 1
echo "Working in $TMPDIR"
pushd $TMPDIR

echo "Extracting $ORIG_ISO to ./newiso/"
mkdir ./origiso
mount -o loop $ORIG_ISO ./origiso
mkdir ./newiso
rsync -a ./origiso/ ./newiso/
umount ./origiso

# Before f12 images/stage2.img held most of anaconda's files
#   but using squashfs 3.0 which v4.0 cannot read
# From f12 to f14 it was images/install.img
# After f14 it is all in isolinux/initrd.img

uncompressInitrd $VER

if [ $VER -gt 15 ]; then
    echo "Detected anaconda release 16+"
    pushd ./newinitrd
    # Do f16 and later operations on ./newinitrd
    unpackRPMs

    cp ./usr/share/anaconda/raidstart-stub ./usr/bin/raidstart
    cp ./usr/share/anaconda/raidstop-stub ./usr/bin/raidstop
    cp ./usr/share/anaconda/list-harddrives-stub ./usr/bin/list-harddrives
    cp ./usr/share/anaconda/loadkeys-stub ./usr/bin/loadkeys
    cp ./usr/$LIBDIR/python?.?/site-packages/pyanaconda/sitecustomize.py ./usr/$LIBDIR/python?.?/site-packages

    # Copy loader to the initrd
    cp ./usr/$LIBDIR/anaconda/loader ./sbin/
    cp ./usr/share/anaconda/loader.tr ./etc/
elif [ $VER -gt 14 ]; then
    echo "Detected anaconda release 15"
    pushd ./newinitrd
    unpackRPMs

    cp ./usr/share/anaconda/raidstart-stub ./usr/bin/raidstart
    cp ./usr/share/anaconda/raidstop-stub ./usr/bin/raidstop
    cp ./usr/share/anaconda/list-harddrives-stub ./usr/bin/list-harddrives
    cp ./usr/share/anaconda/loadkeys-stub ./usr/bin/loadkeys
    cp ./usr/$LIBDIR/python?.?/site-packages/pyanaconda/sitecustomize.py ./usr/$LIBDIR/python?.?/site-packages

    # Copy loader to the initrd
    cp ./usr/$LIBDIR/anaconda/loader ./sbin/
    cp ./usr/share/anaconda/loader.tr ./etc/
    cp ./usr/$LIBDIR/anaconda/init ./sbin/
elif [ $VER -gt 11 ]; then
    echo "Extracting ./newiso/images/install.img to ./newinstall/"
    mkdir ./install
    mount -o loop ./newiso/images/install.img install/
    mkdir ./newinstall
    rsync -a ./install/ ./newinstall/
    umount ./install

    pushd ./newinstall
    unpackRPMs

    if [ $VER -gt 13 ]; then
        echo "Detected anaconda release 14"
        # = anaconda-14.* do this
        cp ./usr/share/anaconda/raidstart-stub ./usr/bin/raidstart
        cp ./usr/share/anaconda/raidstop-stub ./usr/bin/raidstop
        cp ./usr/share/anaconda/list-harddrives-stub ./usr/bin/list-harddrives
        cp ./usr/share/anaconda/loadkeys-stub ./usr/bin/loadkeys
        cp ./usr/share/anaconda/mknod-stub ./usr/bin/mknod
        cp ./usr/share/anaconda/restart-anaconda ./usr/bin/restart-anaconda
        cp ./usr/sbin/anaconda ./usr/bin/anaconda

        cp ./usr/$LIBDIR/python?.?/site-packages/pyanaconda/sitecustomize.py ./usr/$LIBDIR/python?.?/site-packages
    elif [ $VER -gt 11 ]; then
        echo "Detected anaconda release 12 or 13"
        # 12 or 13 do this
        cp ./usr/$LIBDIR/anaconda/raidstart-stub ./usr/bin/raidstart
        cp ./usr/$LIBDIR/anaconda/raidstop-stub ./usr/bin/raidstop
        cp ./usr/$LIBDIR/anaconda/losetup-stub ./usr/bin/losetup
        cp ./usr/$LIBDIR/anaconda/list-harddrives-stub ./usr/bin/list-harddrives
        cp ./usr/$LIBDIR/anaconda/loadkeys-stub ./usr/bin/loadkeys
        cp ./usr/$LIBDIR/anaconda/mknod-stub ./usr/bin/mknod
        cp ./usr/$LIBDIR/anaconda/syslogd-stub ./usr/bin/syslogd
        cp ./usr/sbin/anaconda ./usr/bin/anaconda
        cp ./usr/$LIBDIR/anaconda-runtime/lib* ./usr/lib
        cp ./usr/$LIBDIR/anaconda/sitecustomize.py ./usr/lib/python?.?/site-packages
    fi

    # Copy loader to the initrd
    cp ./usr/$LIBDIR/anaconda/loader ../newinitrd/sbin/
    cp ./usr/share/anaconda/loader.tr ../newinitrd/etc/
    cp ./usr/$LIBDIR/anaconda/init ../newinitrd/sbin/

    # non-standard, used for debugging stage1 problems
    cp ./usr/bin/{ls,cat,less} ../newinitrd/sbin/
else
    echo "Cannot update stage2.img (old squashfs version). Only updating initrd"
    mkdir ./newinstall
    pushd ./newinstall
    unpackRPMs

    # Copy loader to the initrd
    cp ./usr/lib/anaconda-runtime/loader/loader ../newinitrd/sbin/
    cp ./usr/lib/anaconda-runtime/loader/loader.tr ../newinitrd/etc/
    cp ./usr/lib/anaconda-runtime/loader/init ../newinitrd/sbin/

    # non-standard, used for debugging stage1 problems
    cp ./usr/bin/{ls,cat,less} ../newinitrd/sbin/
fi
popd

if [ $RUNSHELL -eq 1 ]; then
    echo "Make changes inside ./newinitrd and ./newinstall, then exit to finish"
    /bin/sh
    echo "Finishing build of new.iso"
fi

# Create the new initrd.img
pushd ./newinitrd
if [ $VER -gt 15 ]; then
    find . |cpio --quiet -c -o | xz -9 --check=crc32 > ../initrd.img
else
    find . |cpio --quiet -c -o | gzip -9 > ../initrd.img
fi
popd

# Stuff new initrd.img into the newiso tree
find ./newiso/ -iname initrd.img -exec cp initrd.img {} \;

# Make a new install.img if needed (f12 thru f14)
if [ $VER -gt 11 -a $VER -lt 15 ]; then
    echo "Create new install.img"
    mksquashfs ./newinstall install.img -all-root -no-fragments -no-progress
    find ./newiso/ -iname install.img -exec cp install.img {} \;
fi

if [ $SKIPISO -eq 0 ]; then
    # Make a new .iso image
    BOOTISO="./new.iso"
    TOPDESTPATH="./newiso"
    CDLABEL="Fedora"
    rm $TOPDESTPATH/isolinux/boot.cat
    echo "Build new iso"
    doPostImages

    mv new.iso $DEST
    echo "new.iso is in $DEST"
else
    cp initrd.img $DEST
    if [ -f "install.img" ]; then
        cp install.img $DEST
    fi
fi

# Exit $TMPDIR
popd
if [ $LEAVETMP -eq 0 ]; then
    rm -rf $TMPDIR
fi

if [ $VER -lt 12 ]; then
    echo "WARNING: stage2.img was not updated due to older squashfs version."
    echo "WARNING: Only the initrd.img was updated."
fi

exit 0

