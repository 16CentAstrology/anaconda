#
# Copyright (C) 2011 Red Hat, Inc.
#
# This copyrighted material is made available to anyone wishing to use,
# modify, copy, or redistribute it subject to the terms and conditions of
# the GNU General Public License v.2, or (at your option) any later version.
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY expressed or implied, including the implied warranties of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.  You should have received a copy of the
# GNU General Public License along with this program; if not, write to the
# Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
# 02110-1301, USA.  Any Red Hat trademarks that are incorporated in the
# source code or documentation are not subject to the GNU General Public
# License and may only be used or replicated with the express permission of
# Red Hat, Inc.
#

import os
import re
from glob import glob

from pyanaconda.core import util
from blivet.devicelibs import raid

from pyanaconda.bootloader.base import BootLoaderError, Arguments, BootLoader
from pyanaconda.bootloader.efi import EFIGRUB1, EFIGRUB, Aarch64EFIGRUB, ArmEFIGRUB, MacEFIGRUB
from pyanaconda.bootloader.grub import GRUB
from pyanaconda.bootloader.grub2 import GRUB2, IPSeriesGRUB2
from pyanaconda.bootloader.image import LinuxBootLoaderImage, TbootLinuxBootLoaderImage
from pyanaconda.core.constants import BOOTLOADER_TYPE_EXTLINUX
from pyanaconda.modules.common.constants.objects import BOOTLOADER
from pyanaconda.modules.common.constants.services import STORAGE
from pyanaconda.product import productName
from pyanaconda.flags import flags
from pyanaconda.errors import errorHandler, ERROR_RAISE, ZIPLError
from pyanaconda import platform
from pyanaconda.core.configuration.anaconda import conf

from pyanaconda.anaconda_loggers import get_module_logger
log = get_module_logger(__name__)


# Inherit abstract methods from BootLoader
# pylint: disable=abstract-method
class YabootBase(BootLoader):
    def write_config_password(self, config):
        if self.password:
            config.write("password=%s\n" % self.password)
            config.write("restricted\n")

    def write_config_images(self, config):
        for image in self.images:
            if not isinstance(image, LinuxBootLoaderImage):
                # mac os images are handled specially in the header on mac
                continue

            args = Arguments()
            if self.password:
                args.add("rd.shell=0")
            if image.initrd:
                initrd_line = "\tinitrd=%s/%s\n" % (self.boot_prefix,
                                                    image.initrd)
            else:
                initrd_line = ""

            root_device_spec = image.device.fstab_spec
            if root_device_spec.startswith("/"):
                root_line = "\troot=%s\n" % root_device_spec
            else:
                args.add("root=%s" % root_device_spec)
                root_line = ""

            args.update(self.boot_args)
            log.info("bootloader.py: used boot args: %s ", args)

            stanza = ("image=%(boot_prefix)s%(kernel)s\n"
                      "\tlabel=%(label)s\n"
                      "\tread-only\n"
                      "%(initrd_line)s"
                      "%(root_line)s"
                      "\tappend=\"%(args)s\"\n\n"
                      % {"kernel": image.kernel, "initrd_line": initrd_line,
                         "label": self.image_label(image),
                         "root_line": root_line, "args": args,
                         "boot_prefix": self.boot_prefix})
            config.write(stanza)


class Yaboot(YabootBase):
    name = "Yaboot"
    _config_file = "yaboot.conf"
    prog = "ybin"
    image_label_attr = "short_label"
    packages = ["yaboot"]

    # stage2 device requirements
    stage2_device_types = ["partition", "mdarray"]
    stage2_raid_levels = [raid.RAID1]

    #
    # configuration
    #

    @property
    def config_dir(self):
        conf_dir = "/etc"
        if self.stage2_device.format.mountpoint == "/boot":
            conf_dir = "/boot/etc"
        return conf_dir

    @property
    def config_file(self):
        return "%s/%s" % (self.config_dir, self._config_file)

    def write_config_header(self, config):
        if self.stage2_device.type == "mdarray":
            boot_part_num = self.stage2_device.parents[0].parted_partition.number
        else:
            boot_part_num = self.stage2_device.parted_partition.number

        # yaboot.conf timeout is in tenths of a second. Brilliant.
        header = ("# yaboot.conf generated by anaconda\n\n"
                  "boot=%(stage1dev)s\n"
                  "init-message=\"Welcome to %(product)s!\\nHit <TAB> for "
                  "boot options\"\n\n"
                  "partition=%(part_num)d\n"
                  "timeout=%(timeout)d\n"
                  "install=/usr/lib/yaboot/yaboot\n"
                  "delay=5\n"
                  "enablecdboot\n"
                  "enableofboot\n"
                  "enablenetboot\n"
                  % {"stage1dev": self.stage1_device.path,
                     "product": productName, "part_num": boot_part_num,
                     "timeout": self.timeout * 10})
        config.write(header)
        self.write_config_variant_header(config)
        self.write_config_password(config)
        config.write("\n")

    def write_config_variant_header(self, config):
        config.write("nonvram\n")
        config.write("mntpoint=/boot/yaboot\n")
        config.write("usemount\n")

    def write_config_post(self):
        super().write_config_post()

        # make symlink in /etc to yaboot.conf if config is in /boot/etc
        etc_yaboot_conf = util.getSysroot() + "/etc/yaboot.conf"
        if not os.access(etc_yaboot_conf, os.R_OK):
            try:
                os.symlink("../boot/etc/yaboot.conf", etc_yaboot_conf)
            except OSError as e:
                log.error("failed to create /etc/yaboot.conf symlink: %s", e)

    def write_config(self):
        if not os.path.isdir(util.getSysroot() + self.config_dir):
            os.mkdir(util.getSysroot() + self.config_dir)

        # this writes the config
        super().write_config()

    #
    # installation
    #

    def install(self, args=None):
        args = ["-f", "-C", self.config_file]
        rc = util.execInSysroot(self.prog, args)
        if rc:
            raise BootLoaderError("boot loader installation failed")


class MacYaboot(Yaboot):
    prog = "mkofboot"
    can_dual_boot = True

    #
    # configuration
    #

    def write_config_variant_header(self, config):
        try:
            mac_os = [i for i in self.chain_images if i.label][0]
        except IndexError:
            pass
        else:
            config.write("macosx=%s\n" % mac_os.device.path)

        config.write("magicboot=/usr/lib/yaboot/ofboot\n")


class ZIPL(BootLoader):
    name = "ZIPL"
    config_file = "/etc/zipl.conf"
    packages = ["s390utils-base"]

    # stage2 device requirements
    stage2_device_types = ["partition"]

    @property
    def stage2_format_types(self):
        if productName.startswith("Red Hat "):          # pylint: disable=no-member
            return ["xfs", "ext4", "ext3", "ext2"]
        else:
            return ["ext4", "ext3", "ext2", "xfs"]

    image_label_attr = "short_label"
    preserve_args = ["cio_ignore", "rd.znet", "rd_ZNET", "zfcp.allow_lun_scan"]

    def __init__(self):
        super().__init__()
        self.stage1_name = None

    #
    # configuration
    #

    @property
    def boot_dir(self):
        return "/boot"

    def write_config_image(self, config, image, args):
        if image.initrd:
            initrd_line = "\tramdisk=%s/%s\n" % (self.boot_dir, image.initrd)
        else:
            initrd_line = ""

        stanza = ("[%(label)s]\n"
                  "\timage=%(boot_dir)s/%(kernel)s\n"
                  "%(initrd_line)s"
                  "\tparameters=\"%(args)s\"\n"
                  % {"label": self.image_label(image),
                     "kernel": image.kernel, "initrd_line": initrd_line,
                     "args": args,
                     "boot_dir": self.boot_dir})
        config.write(stanza)

    def update_bls_args(self, image, args):
        machine_id_path = util.getSysroot() + "/etc/machine-id"
        if not os.access(machine_id_path, os.R_OK):
            log.error("failed to read machine-id file")
            return

        with open(machine_id_path, "r") as fd:
            machine_id = fd.readline().strip()

        bls_dir = "%s%s/loader/entries/" % (util.getSysroot(), self.boot_dir)

        if image.kernel == "vmlinuz-0-rescue-" + machine_id:
            bls_path = "%s%s-0-rescue.conf" % (bls_dir, machine_id)
        else:
            bls_path = "%s%s-%s.conf" % (bls_dir, machine_id, image.version)

        if not os.access(bls_path, os.W_OK):
            log.error("failed to update boot args in BLS file %s", bls_path)
            return

        with open(bls_path, "r") as bls:
            lines = bls.readlines()
            for i, line in enumerate(lines):
                if line.startswith("options "):
                    lines[i] = "options %s\n" % (args)

        with open(bls_path, "w") as bls:
            bls.writelines(lines)

    def write_config_images(self, config):
        for image in self.images:
            if "kdump" in (image.initrd or image.kernel):
                # no need to create bootloader entries for kdump
                continue

            args = Arguments()
            args.add("root=%s" % image.device.fstab_spec)
            args.update(self.boot_args)
            if image.device.type == "btrfs subvolume":
                args.update(["rootflags=subvol=%s" % image.device.name])
            log.info("bootloader.py: used boot args: %s ", args)

            if self.use_bls:
                self.update_bls_args(image, args)
            else:
                self.write_config_image(config, image, args)

    def write_config_header(self, config):
        header = ("[defaultboot]\n"
                  "defaultauto\n"
                  "prompt=1\n"
                  "timeout={}\n"
                  "target=/boot\n")
        config.write(header.format(self.timeout))

        if self.use_bls and os.path.exists(util.getSysroot() + "/usr/sbin/new-kernel-pkg"):
            log.warning("BLS support disabled due new-kernel-pkg being present")
            self.use_bls = False

        if not self.use_bls:
            config.write("default={}\n".format(self.image_label(self.default)))

    #
    # installation
    #

    def install(self, args=None):
        buf = util.execWithCapture("zipl", [], root=util.getSysroot())
        for line in buf.splitlines():
            if line.startswith("Preparing boot device: "):
                # Output here may look like:
                #     Preparing boot device: dasdb (0200).
                #     Preparing boot device: dasdl.
                # We want to extract the device name and pass that.
                name = re.sub(r".+?: ", "", line)
                self.stage1_name = re.sub(r"(\s\(.+\))?\.$", "", name)
            # a limitation of s390x is that the kernel parameter list must not
            # exceed 896 bytes; there is nothing we can do about this, so just
            # catch the error and show it to the user instead of crashing
            elif line.startswith("Error: The length of the parameters "):
                errorHandler.cb(ZIPLError(line))

        if not self.stage1_name:
            raise BootLoaderError("could not find IPL device")

        # do the reipl
        util.reIPL(self.stage1_name)

class EXTLINUX(BootLoader):
    name = "EXTLINUX"
    _config_file = "extlinux.conf"
    _config_dir = "/boot/extlinux"

    stage2_format_types = ["ext4", "ext3", "ext2"]
    stage2_device_types = ["partition"]
    stage2_bootable = True

    # The extlinux bootloader doesn't have BLS support, the old grubby is needed
    packages = ["syslinux-extlinux", "grubby-deprecated"]

    @property
    def config_file(self):
        return "%s/%s" % (self._config_dir, self._config_file)

    @property
    def boot_prefix(self):
        """ Prefix, if any, to paths in /boot. """
        if self.stage2_device.format.mountpoint == "/":
            prefix = "/boot"
        else:
            prefix = ""

        return prefix

    def write_config_console(self, config):
        if not self.console:
            return

        console_arg = "console=%s" % self.console
        if self.console_options:
            console_arg += ",%s" % self.console_options
        self.boot_args.add(console_arg)

    def write_config_images(self, config):
        self.write_config_console(config)
        for image in self.images:
            args = Arguments()
            args.update(["root=%s" % image.device.fstab_spec, "ro"])
            if image.device.type == "btrfs subvolume":
                args.update(["rootflags=subvol=%s" % image.device.name])
            args.update(self.boot_args)
            log.info("bootloader.py: used boot args: %s ", args)

            # extlinux labels cannot have spaces
            label = "%s(%s)" % (self.image_label(image), image.version)
            label = label.replace(" ", "")
            stanza = ("label %(label)s\n"
                      "\tkernel %(boot_prefix)s/%(kernel)s\n"
                      "\tinitrd %(boot_prefix)s/%(initrd)s\n"
                      "\tappend %(args)s\n\n"
                      % {"label": label,
                         "kernel": image.kernel,
                         "initrd": image.initrd,
                         "args": args,
                         "boot_prefix": self.boot_prefix})
            config.write(stanza)

    def write_config_header(self, config):
        header = ("# extlinux.conf generated by anaconda\n\n"
                  "ui menu.c32\n\n"
                  "menu autoboot Welcome to %(productName)s. Automatic boot in # second{,s}. Press a key for options.\n"
                  "menu title %(productName)s Boot Options.\n"
                  "menu hidden\n\n"
                  "timeout %(timeout)d\n"
                  "#totaltimeout 9000\n\n"
                  % {"productName": productName, "timeout": self.timeout * 10})
        config.write(header)
        if self.default is not None:
            config.write("default %(default)s\n\n" % {"default": self.image_label(self.default).replace(" ", "")})
        self.write_config_password(config)

    def write_config_password(self, config):
        if self.password:
            config.write("menu master passwd %s\n" % self.password)
            config.write("menu notabmsg Press [Tab] and enter the password to edit options")

    def write_config_post(self):
        etc_extlinux = os.path.normpath(util.getSysroot() + "/etc/" + self._config_file)
        if not os.access(etc_extlinux, os.R_OK):
            try:
                os.symlink("../boot/%s" % self._config_file, etc_extlinux)
            except OSError as e:
                log.warning("failed to create /etc/extlinux.conf symlink: %s", e)

    #
    # installation
    #

    def install(self, args=None):
        args = ["--install", self._config_dir]
        rc = util.execInSysroot("extlinux", args)

        if rc:
            raise BootLoaderError("boot loader install failed")


# every platform that wants a bootloader needs to be in this dict
bootloader_by_platform = {
    platform.X86: GRUB2,
    platform.EFI: EFIGRUB,
    platform.MacEFI: MacEFIGRUB,
    platform.PPC: GRUB2,
    platform.IPSeriesPPC: IPSeriesGRUB2,
    platform.NewWorldPPC: MacYaboot,
    platform.S390: ZIPL,
    platform.Aarch64EFI: Aarch64EFIGRUB,
    platform.ARM: EXTLINUX,
    platform.ArmEFI: ArmEFIGRUB,
}

if flags.cmdline.get("legacygrub") == "1":
    log.info("Using legacy grub (0.9x)")
    bootloader_by_platform.update({
        platform.X86: GRUB,
        platform.EFI: EFIGRUB1,
    })

def get_bootloader():
    bootloader_proxy = STORAGE.get_proxy(BOOTLOADER)
    platform_name = platform.platform.__class__.__name__

    if bootloader_proxy.BootloaderType == BOOTLOADER_TYPE_EXTLINUX:
        cls = EXTLINUX
    else:
        cls = bootloader_by_platform.get(platform.platform.__class__, BootLoader)
    log.info("bootloader %s on %s platform", cls.__name__, platform_name)
    return cls()


# anaconda-specific functions

def writeSysconfigKernel(storage, version):
    # get the name of the default kernel package based on the version
    kernel_basename = "vmlinuz-" + version
    kernel_file = "/boot/%s" % kernel_basename
    if not os.path.isfile(util.getSysroot() + kernel_file):
        efi_dir = conf.bootloader.efi_dir
        kernel_file = "/boot/efi/EFI/%s/%s" % (efi_dir, kernel_basename)
        if not os.path.isfile(util.getSysroot() + kernel_file):
            log.error("failed to recreate path to default kernel image")
            return

    try:
        import rpm
    except ImportError:
        log.error("failed to import rpm python module")
        return

    ts = rpm.TransactionSet(util.getSysroot())
    mi = ts.dbMatch('basenames', kernel_file)
    try:
        h = next(mi)
    except StopIteration:
        log.error("failed to get package name for default kernel")
        return

    kernel = h.name.decode()

    f = open(util.getSysroot() + "/etc/sysconfig/kernel", "w+")
    f.write("# UPDATEDEFAULT specifies if new-kernel-pkg should make\n"
            "# new kernels the default\n")
    # only update the default if we're setting the default to linux (#156678)
    if storage.bootloader.default.device == storage.root_device:
        f.write("UPDATEDEFAULT=yes\n")
    else:
        f.write("UPDATEDEFAULT=no\n")
    f.write("\n")
    f.write("# DEFAULTKERNEL specifies the default kernel package type\n")
    f.write("DEFAULTKERNEL=%s\n" % kernel)
    if storage.bootloader.trusted_boot:
        f.write("# HYPERVISOR specifies the default multiboot kernel\n")
        f.write("HYPERVISOR=/boot/tboot.gz\n")
        f.write("HYPERVISOR_ARGS=logging=vga,serial,memory\n")
    f.close()

def writeBootLoaderFinal(storage, payload, ksdata):
    """ Do the final write of the bootloader. """

    # set up dracut/fips boot args
    # XXX FIXME: do this from elsewhere?
    storage.bootloader.set_boot_args(storage=storage,
                                     payload=payload)
    try:
        storage.bootloader.write()
    except BootLoaderError as e:
        log.error("bootloader.write failed: %s", e)
        if errorHandler.cb(e) == ERROR_RAISE:
            raise

def writeBootLoader(storage, payload, ksdata):
    """ Write bootloader configuration to disk.

        When we get here, the bootloader will already have a default linux
        image. We only have to add images for the non-default kernels and
        adjust the default to reflect whatever the default variant is.
    """
    if not storage.bootloader.skip_bootloader:
        stage1_device = storage.bootloader.stage1_device
        log.info("boot loader stage1 target device is %s", stage1_device.name)
        stage2_device = storage.bootloader.stage2_device
        log.info("boot loader stage2 target device is %s", stage2_device.name)

    storage.bootloader.menu_auto_hide = conf.bootloader.menu_auto_hide

    # Bridge storage EFI configuration to bootloader
    if hasattr(storage.bootloader, 'efi_dir'):
        storage.bootloader.efi_dir = conf.bootloader.efi_dir

    # Currently just rpmostreepayload shortcuts the rest of everything below
    if payload.handlesBootloaderConfiguration:
        if storage.bootloader.skip_bootloader:
            log.info("skipping boot loader install per user request")
            return
        writeBootLoaderFinal(storage, payload, ksdata)
        return

    # get a list of installed kernel packages
    # add whatever rescue kernels we can find to the end
    kernel_versions = list(payload.kernelVersionList)

    rescue_versions = glob(util.getSysroot() + "/boot/vmlinuz-*-rescue-*")
    rescue_versions += glob(
        util.getSysroot() + "/boot/efi/EFI/%s/vmlinuz-*-rescue-*" % conf.bootloader.efi_dir)
    kernel_versions += (f.split("/")[-1][8:] for f in rescue_versions)

    if not kernel_versions:
        log.warning("no kernel was installed -- boot loader config unchanged")
        return

    # all the linux images' labels are based on the default image's
    base_label = productName
    base_short_label = "linux"

    # The first one is the default kernel. Update the bootloader's default
    # entry to reflect the details of the default kernel.
    version = kernel_versions.pop(0)
    default_image = LinuxBootLoaderImage(device=storage.root_device,
                                         version=version,
                                         label=base_label,
                                         short=base_short_label)
    storage.bootloader.add_image(default_image)
    storage.bootloader.default = default_image

    # write out /etc/sysconfig/kernel
    writeSysconfigKernel(storage, version)

    if storage.bootloader.skip_bootloader:
        log.info("skipping boot loader install per user request")
        return

    # now add an image for each of the other kernels
    for version in kernel_versions:
        label = "%s-%s" % (base_label, version)
        short = "%s-%s" % (base_short_label, version)
        if storage.bootloader.trusted_boot:
            image = TbootLinuxBootLoaderImage(device=storage.root_device,
                                              version=version,
                                              label=label, short=short)
        else:
            image = LinuxBootLoaderImage(device=storage.root_device,
                                         version=version,
                                         label=label, short=short)
        storage.bootloader.add_image(image)

    writeBootLoaderFinal(storage, payload, ksdata)
