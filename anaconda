#!/usr/bin/python
#
# anaconda: The Red Hat Linux Installation program
#
# (in alphabetical order...)
#
# Brent Fox <bfox@redhat.com>
# Mike Fulbright <msf@redhat.com>
# Jakub Jelinek <jakub@redhat.com>
# Jeremy Katz <katzj@redhat.com>
# Erik Troan <ewt@rpath.com>
# Matt Wilson <msw@rpath.com>
#
# ... And many others
#
# Copyright 1999-2006 Red Hat, Inc.
#
# This software may be freely redistributed under the terms of the GNU
# library public license.
#
# You should have received a copy of the GNU Library Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#

# This toplevel file is a little messy at the moment...

import sys, os
from optparse import OptionParser

# keep up with process ID of miniwm if we start it

miniwm_pid = None

# Make sure messages sent through python's warnings module get logged.
def AnacondaShowWarning(message, category, filename, lineno, file=sys.stderr):
    log.warning("%s" % warnings.formatwarning(message, category, filename, lineno))

# start miniWM
def startMiniWM(root='/'):
    (rd, wr) = os.pipe()
    childpid = os.fork()
    if not childpid:
	if os.access("./mini-wm", os.X_OK):
	    cmd = "./mini-wm"
	elif os.access(root + "/usr/bin/mini-wm", os.X_OK):
	    cmd = root + "/usr/bin/mini-wm"
	else:
	    return None
	
	os.dup2(wr, 1)
	os.close(wr)
	args = [cmd, '--display', ':1']
	os.execv(args[0], args)
	sys.exit (1)
    else:
	# We need to make sure that mini-wm is the first client to
	# connect to the X server (see bug #108777).  Wait for mini-wm
	# to write back an acknowledge token.
	os.read(rd, 1)

    return childpid

# startup vnc X server
def startVNCServer(vncpassword="", root='/', vncconnecthost="",
		   vncconnectport=""):
    
    def set_vnc_password(root, passwd, passwd_file):
	(pid, fd) = os.forkpty()

	if not pid:
	    os.execv(root + "/usr/bin/vncpasswd", [root + "/usr/bin/vncpasswd", passwd_file])
	    sys.exit(1)

	# read password prompt
	os.read(fd, 1000)

	# write password
	os.write(fd, passwd + "\n")

	# read challenge again, and newline
	os.read(fd, 1000)
	os.read(fd, 1000)

	# write password again
	os.write(fd, passwd + "\n")

	# read remaining output
	os.read(fd, 1000)

	# wait for status
	try:
	    (pid, status) = os.waitpid(pid, 0)
	except OSError, (errno, msg):
	    print __name__, "waitpid:", msg

	return status

    stdoutLog.info(_("Starting VNC..."))

    # figure out host info
    connxinfo = None
    srvname = None
    try:
	import network

	# try to load /tmp/netinfo and see if we can sniff out network info
	netinfo = network.Network()
	srvname = None
	if netinfo.hostname != "localhost.localdomain":
	    srvname = "%s" % (netinfo.hostname,)
	else:
	    for dev in netinfo.netdevices.keys():
		try:
		    ip = isys.getIPAddress(dev)
		    log.info("ip of %s is %s" %(dev, ip))
		except Exception, e:
		    log.error("Got an exception trying to get the ip addr "
			      "of %s: %s" %(dev, e))
		    continue
		if ip == '127.0.0.1' or ip is None:
		    continue
		srvname = ip
		break

	if srvname is not None:
	    connxinfo = "%s:1" % (srvname,)

    except:
	log.error("Unable to determine VNC server network info")
	
    # figure out product info
    if srvname is not None:
	desktopname = _("%s %s installation on host %s") % (product.productName, product.productVersion, srvname)
    else:
	desktopname = _("%s %s installation") % (product.productName, product.productVersion)

    vncpid = os.fork()

    if not vncpid:
	args = [ root + "/usr/bin/Xvnc", ":1", "-nevershared",
		 "-depth", "16", "-geometry", "800x600",
		 "IdleTimeout=0", "-auth", "/dev/null", "-once",
		 "DisconnectClients=false", "desktop=%s" % (desktopname,)]

	# set passwd if necessary
        if vncpassword != "":
	    try:
		rc = set_vnc_password(root, vncpassword, "/tmp/vncpasswd_file")
	    except Exception, e:
		stdoutLog.error("Unknown exception setting vnc password.")
		log.error("Exception was: %s" %(e,))
		rc = 1

	    if rc:
		stdoutLog.warning(_("Unable to set vnc password - using no password!"))
		stdoutLog.warning(_("Make sure your password is at least 6 characters in length."))
	    else:
		args = args + ["-rfbauth", "/tmp/vncpasswd_file"]
	else:
	    # needed if no password specified
	    args = args + ["SecurityTypes=None",]
			     
	tmplogFile = "/tmp/vncserver.log"
	try:
	    err = os.open(tmplogFile, os.O_RDWR | os.O_CREAT)
	    if err < 0:
		sys.stderr.write("error opening %s\n", tmplogFile)
	    else:
		os.dup2(err, 2)
		os.close(err)
	except:
	    # oh well
	    pass

	os.execv(args[0], args)
	sys.exit (1)

    if vncpassword == "":
	stdoutLog.warning(_("\n\nWARNING!!! VNC server running with NO PASSWORD!\n"
			 "You can use the vncpassword=<password> boot option\n"
			 "if you would like to secure the server.\n\n"))
	
    stdoutLog.info(_("The VNC server is now running."))

    if vncconnecthost != "":
	stdoutLog.info(_("Attempting to connect to vnc client on host %s...") % (vncconnecthost,))
	
	hostarg = vncconnecthost
        if vncconnectport != "":
	    hostarg = hostarg + ":" + vncconnectport
	    
	argv = ["/usr/bin/vncconfig", "-display", ":1", "-connect", hostarg]
	ntries = 0
	while 1:
            output = iutil.execWithCapture(argv[0], argv, catchfd=2)

            if output == "":
                stdoutLog.info(_("Connected!"))
                break
            elif output.startswith("connecting") and output.endswith("failed"):
		ntries += 1
		if ntries > 50:
		    stdoutLog.error(_("Giving up attempting to connect after 50 tries!\n"))
		    if connxinfo is not None:
			stdoutLog.info(_("Please manually connect your vnc client to %s to begin the install.") % (connxinfo,))
		    else:	    
			stdoutLog.info(_("Please manually connect your vnc client to begin the install."))
		    break
		    
		stdoutLog.info(output)
		stdoutLog.info(_("Will try to connect again in 15 seconds..."))
		time.sleep(15)
		continue
	    else:
                stdoutLog.critical(output)
	        sys.exit(1)
    else:
	if connxinfo is not None:
	    stdoutLog.info(_("Please connect to %s to begin the install...") % (connxinfo,))
	else:
	    stdoutLog.info(_("Please connect to begin the install..."))

    os.environ["DISPLAY"]=":1"
    doStartupX11Actions()

# function to handle X startup special issues for anaconda
def doStartupX11Actions():
    global miniwm_pid

    # now start up mini-wm
    try:
	miniwm_pid = startMiniWM()
	log.info("Started mini-wm")
    except:
	miniwm_pid = None
	log.error("Unable to start mini-wm")

    # test to setup dpi
    # cant do this if miniwm didnt run because otherwise when
    # we open and close an X connection in the xutils calls
    # the X server will exit since this is the first X
    # connection (if miniwm isnt running)
    if miniwm_pid is not None:
	import xutils

	try:
	    if xutils.screenWidth() > 640:
		dpi = "96"
	    else:
		dpi = "75"


	    xutils.setRootResource('Xcursor.size', '24')
	    xutils.setRootResource('Xcursor.theme', 'Bluecurve')
	    xutils.setRootResource('Xcursor.theme_core', 'true')

	    xutils.setRootResource('Xft.antialias', '1')
	    xutils.setRootResource('Xft.dpi', dpi)
	    xutils.setRootResource('Xft.hinting', '1')
	    xutils.setRootResource('Xft.hintstyle', 'hintslight')
	    xutils.setRootResource('Xft.rgba', 'none')
	except:
	    sys.stderr.write("X SERVER STARTED, THEN FAILED");
	    raise RuntimeError, "X server failed to start"

def doShutdownX11Actions():
    global miniwm_pid
    
    if miniwm_pid is not None:
	try:
	    os.kill(miniwm_pid, 15)
	    os.waitpid(miniwm_pid, 0)
	except:
	    pass

# handle updates of just a single file in a python package
def setupPythonUpdates():
    import glob

    # get the python version.  first of /usr/lib/python*, strip off the
    # first 15 chars
    pyvers = glob.glob("/usr/lib/python*")
    pyver = pyvers[0][15:]
    
    try:
	os.mkdir("/tmp/updates")
    except:
	pass

    for pypkg in ("rhpl", "yum", "rpmUtils", "urlgrabber", "repomd",
		  "pykickstart", "rhpxl"):
	if os.access("/mnt/source/RHupdates/%s" %(pypkg,), os.X_OK):
	    try:
		os.mkdir("/tmp/updates/%s" %(pypkg,))
	    except:
		pass

	    # symlink the existing ones
	    for f in os.listdir("/mnt/source/RHupdates/%s" %(pypkg,)):
		os.symlink("/mnt/source/RHupdates/%s/%s" %(pypkg, f),
			   "/tmp/updates/%s/%s" %(pypkg, f))

	# get the libdir.  *sigh*
	if os.access("/usr/lib64/python%s/site-packages/%s" %(pyver, pypkg),
		     os.X_OK):
	    libdir = "lib64"
        elif os.access("/usr/lib/python%s/site-packages/%s" %(pyver, pypkg),
                       os.X_OK):
	    libdir = "lib"
	else:
            # If the directory doesn't exist, there's nothing to link over.
            # This happens if we forgot to include one of the above packages
            # in the image, for instance.
            return

	if os.access("/tmp/updates/%s" %(pypkg,), os.X_OK):
	    for f in os.listdir("/usr/%s/python%s/site-packages/%s" %(libdir,
								      pyver,
								      pypkg)):
		if os.access("/tmp/updates/%s/%s" %(pypkg, f), os.R_OK):
		    continue
		elif (f.endswith(".pyc") and
		      os.access("/tmp/updates/%s/%s" %(pypkg, f[:-1]),os.R_OK)):
		    # dont copy .pyc files we are replacing with updates
		    continue
		else:
		    os.symlink("/usr/%s/python%s/site-packages/%s/%s" %(libdir,
									pyver,
									pypkg,
									f),
			       "/tmp/updates/%s/%s" %(pypkg, f))
    
# For anaconda in test mode
if (os.path.exists('isys')):
    sys.path.append('isys')
    sys.path.append('textw')
    sys.path.append('iw')
else:
    sys.path.append('/usr/lib/anaconda')
    sys.path.append('/usr/lib/anaconda/textw')
    sys.path.append('/usr/lib/anaconda/iw')

if (os.path.exists('booty')):
    sys.path.append('booty')
    sys.path.append('booty/edd')
else:
    sys.path.append('/usr/lib/booty')

sys.path.append('/usr/share/system-config-keyboard')
sys.path.append('/usr/share/system-config-date')

try:
    import updates_disk_hook
except ImportError:
    pass

# Set up logging as early as possible.
import logging
from anaconda_log import logger, logLevelMap

log = logging.getLogger("anaconda")
stdoutLog = logging.getLogger("anaconda.stdout")

# pull this in to get product name and versioning
import product

# do this early to keep our import footprint as small as possible
# Python passed my path as argv[0]!
# if sys.argv[0][-7:] == "syslogd":
if len(sys.argv) > 1:
    if sys.argv[1] == "--syslogd":
	from syslogd import Syslogd
	root = sys.argv[2]
	output = sys.argv[3]
	syslog = Syslogd (root, open (output, "a"))
	# this never returns

# this handles setting up RHupdates for pypackages to minimize the set needed
setupPythonUpdates()

import signal, traceback, string, isys, iutil, time
from exception import handleException
import dispatch
import warnings
import rhpl
from flags import flags
from rhpl.translate import _, textdomain, addPoPath

if rhpl.getArch() != "s390" and os.access("/dev/tty3", os.W_OK):
    logger.addFileHandler ("/dev/tty3", log)

warnings.showwarning = AnacondaShowWarning

if os.path.isdir("/mnt/source/RHupdates/po"):
    log.info("adding RHupdates/po")
    addPoPath("/mnt/source/RHupdates/po")
if os.path.isdir("/tmp/updates/po"):
    log.info("adding /tmp/updates/po")    
    addPoPath("/tmp/updates/po")
textdomain("anaconda")

# reset python's default SIGINT handler
signal.signal(signal.SIGINT, signal.SIG_DFL)
signal.signal(signal.SIGSEGV, isys.handleSegv)

# Silly GNOME stuff
if os.environ.has_key('HOME') and not os.environ.has_key("XAUTHORITY"):
    os.environ['XAUTHORITY'] = os.environ['HOME'] + '/.Xauthority'
os.environ['HOME'] = '/tmp'
os.environ['LC_NUMERIC'] = 'C'
os.environ["GCONF_GLOBAL_LOCKS"] = "1"

# In theory, this gets rid of our LVM file descriptor warnings
os.environ["LVM_SUPPRESS_FD_WARNINGS"] = "1"

# we can't let the LD_PRELOAD hang around because it will leak into
# rpm %post and the like.  ick :/
if os.environ.has_key("LD_PRELOAD"):
    del os.environ["LD_PRELOAD"]

# we need to do this really early so we make sure its done before rpm
# is imported
iutil.writeRpmPlatform()

extraModules = []               # XXX: this would be better as a callback
runres_override = False
graphical_failed = 0
instClass = None                # the install class to use

#
# xcfg       - xserver info (?)
# mousehw    - mouseinfo info
# videohw    - videocard info
# monitorhw  - monitor info
#
xcfg = None
monitorhw = None
videohw = None
mousehw = None
kbd = None
vncpassword = ""
vncconnecthost = ""
vncconnectport = ""

def resolution_cb (option, opt_str, value, parser):
    global runres_override
    parser.values.runres = value
    runres_override = True

def rootpath_cb (option, opt_str, value, parser):
    parser.values.rootPath = value
    flags.setupFilesystems = False
    flags.rootpath = True

op = OptionParser()
# Interface
op.add_option("-C", "--cmdline", dest="display_mode", action="store_const", const="c")
op.add_option("-G", "--graphical", dest="display_mode", action="store_const", const="g")
op.add_option("-T", "--text", dest="display_mode", action="store_const", const="t")

# Method of operation
op.add_option("--autostep", action="store_true", default=False)
op.add_option("-d", "--debug", dest="debug", action="store_true", default=False)
op.add_option("--expert", action="store_true", default=False)
op.add_option("--kickstart", dest="ksfile")
op.add_option("-m", "--method", default=None)
op.add_option("--rescue", dest="progmode", action="store_const", const="rescue", default="install")
op.add_option("-r", "--rootpath", action="callback", callback=rootpath_cb, dest="rootPath",
              default="/mnt/sysimage", nargs=1)
op.add_option("-t", "--test", action="store_true", default=False)

# Display
op.add_option("--headless", dest="isHeadless", action="store_true", default=False)
op.add_option("--lowres", dest="resolution", action="store_const", const="640x480")
op.add_option("--nofb")
op.add_option("--resolution", action="callback", callback=resolution_cb, dest="runres",
              default="800x600", nargs=1)
op.add_option("--serial", action="store_true", default=False)
op.add_option("--skipddc", action="store_true", default=False)
op.add_option("--usefbx", dest="useFBX", action="store_true", default=False)
op.add_option("--vesa", dest="forcevesa", action="store_true", default=False)
op.add_option("--virtpconsole")
op.add_option("--vnc", action="store_true", default=False)
op.add_option("--vncconnect")

# Language
op.add_option("--keymap")
op.add_option("--kbdtype")
op.add_option("--lang")

# Obvious
op.add_option("--loglevel")
op.add_option("--syslog")

op.add_option("--noselinux", dest="selinux", action="store_false", default=True)
op.add_option("--selinux", action="store_true")

op.add_option("--nodmraid", dest="dmraid", action="store_false", default=True)
op.add_option("--dmraid", action="store_true")

op.add_option("--noiscsi", dest="iscsi", action="store_false", default=False)
op.add_option("--iscsi", action="store_true")

# Miscellaneous
op.add_option("--module", action="append", default=[])
op.add_option("--nomount", dest="rescue_nomount", action="store_true", default=False)

(opts, args) = op.parse_args()

# Now that we've got arguments, do some extra processing.
if opts.ksfile:
    from kickstart import Kickstart
    instClass = Kickstart(opts.ksfile, opts.serial)

if opts.loglevel and logLevelMap.has_key(opts.loglevel):
    log.setHandlersLevel(logLevelMap[opts.loglevel])

if opts.syslog:
    if opts.syslog.find(":") != -1:
        (host, port) = opts.syslog.split(":")
        logger.addSysLogHandler(log, host, port=int(port))
    else:
        logger.addSysLogHandler(log, opts.syslog)

if opts.method and opts.method[0] == '@':
    # ftp installs pass the password via a file in /tmp so
    # ps doesn't show it
    filename = method[1:]
    method = open(filename, "r").readline()
    opts.method = method[:len(method) - 1]
    os.unlink(filename)

if opts.module:
    for mod in opts.module:
        (path, name) = string.split(mod, ":")
        extraModules.append((path, name))

if opts.test:
    flags.test = 1
    flags.setupFilesystems = 0

if opts.vnc:
    flags.usevnc = 1

    # see if there is a vnc password file
    try:
        pfile = open("/tmp/vncpassword.dat", "r")
        vncpassword=pfile.readline().strip()
        pfile.close()
        os.unlink("/tmp/vncpassword.dat")
    except:
        vncpassword=""
        pass
    
    # check length of vnc password	
    if vncpassword != "" and len(vncpassword) < 6:
        from snack import *
    
        screen = SnackScreen()
        ButtonChoiceWindow(screen, _('VNC Password Error'),
                           _('You need to specify a vnc password of at least 6 characters long.\n\n'
    		     'Press <return> to reboot your system.\n'), 
    		   buttons = (_("OK"),))
        screen.finish()
        sys.exit(0)

if opts.vncconnect:
    cargs = string.split(opts.vncconnect, ":")
    vncconnecthost = cargs[0]
    if len(cargs) > 1:
        if len(cargs[1]) > 0:
	    vncconnectport = cargs[1]

# probing for hardware on an s390 seems silly...
if rhpl.getArch() == "s390":
    opts.isHeadless = True

#
# must specify install, rescue mode
#

if opts.progmode == "rescue":
    if not opts.method:
	sys.stderr.write('--method required for rescue mode\n')
	sys.exit(1)

    import rescue, instdata
    
    id = instdata.InstallData([], "fd0", opts.method, opts.display_mode)
    rescue.runRescue(opts.rootPath, not opts.rescue_nomount, id)

    # shouldn't get back here
    sys.exit(1)
else:
    if not opts.method:
	sys.stderr.write('no install method specified\n')
	sys.exit(1)

#
# Here we have a hook to pull in second half of kickstart file via https
# if desired.
#
if opts.ksfile:
    from kickstart import pullRemainingKickstartConfig, KickstartError
    from kickstart import VNCHandlers
    from pykickstart.data import KickstartData
    from pykickstart.parser import KickstartParser

    try:
	rc = pullRemainingKickstartConfig(opts.ksfile)
    except KickstartError, msg:
	rc = msg
    except:
	rc = _("Unknown Error")

    if rc is not None:
	stdoutLog.critical(_("Error pulling second part of kickstart config: %s!") % rc)
	sys.exit(1)

    # now see if they enabled vnc via the kickstart file. Note that command
    # line options for password, connect host and port override values in
    # kickstart file
    ksdata = KickstartData()
    ksparser = KickstartParser(ksdata, VNCHandlers(ksdata),
                               missingIncludeIsFatal=False)
    ksparser.readKickstart(opts.ksfile)

    ksusevnc = ksdata.vnc["enabled"]

    if ksusevnc:
	flags.usevnc = 1

	ksvncpasswd = ksdata.vnc["password"]
	ksvnchost = ksdata.vnc["host"]
	ksvncport = ksdata.vnc["port"]

	if vncpassword == "":
	    vncpassword = ksvncpasswd

	if vncconnecthost == "":
	    vncconnecthost = ksvnchost

	if vncconnectport == "":
	    vncconnectport = ksvncport

#
# Determine install method - GUI or TUI
#
# use GUI by default except for install methods that were traditionally
# text based due to the requirement of a small stage 2
#
# if display_mode wasnt set by command line parameters then set default
#

if not opts.display_mode:
    if (opts.method and
	opts.method.startswith('ftp://') or
	opts.method.startswith('http://')):
	opts.display_mode = 't'
    else:
	opts.display_mode = 'g'

if opts.debug:
    import pdb
    pdb.set_trace()

# let people be stupid
## # don't let folks do anything stupid on !s390
## if (not flags.test and os.getpid() > 90 and flags.setupFilesystems and
##     not rhpl.getArch() == "s390"):
##     sys.stderr.write(
##         "You're running me on a live system! that's incredibly stupid.\n")
##     sys.exit(1)

import isys
import instdata
import floppy
import vnc

if not opts.isHeadless:
    try:
	import xsetup
	import rhpxl.xhwstate as xhwstate
    except ImportError:
	opts.isHeadless = 1
import rhpl.keyboard as keyboard

log.info("Display mode = %s", opts.display_mode)
log.info("Method = %s", opts.method)

#
# override display mode if machine cannot nicely run X
#
if (not flags.test):
    if (iutil.memInstalled() < isys.MIN_GUI_RAM):
	stdoutLog.warning(_("You do not have enough RAM to use the graphical "
			    "installer.  Starting text mode."))
	opts.display_mode = 't'
	time.sleep(2)


if iutil.memInstalled() < isys.MIN_RAM:
    from snack import *

    screen = SnackScreen()
    ButtonChoiceWindow(screen, _('Fatal Error'),
			_('You do not have enough RAM to install %s '
			  'on this machine.\n'
			  '\n'
			  'Press <return> to reboot your system.\n')
		       %(product.productName,), 
		       buttons = (_("OK"),))
    screen.finish()
    sys.exit(0)

# create character device nodes if we're not running in test mode - have
# to do this early sine it's used for Synaptics, etc.
if not flags.test:
    iutil.makeCharDeviceNodes()

#
# if no instClass declared by user figure it out based on other cmdline args
#
if not instClass:
    from installclass import DefaultInstall, availableClasses
    instClass = DefaultInstall(flags.expert)

    allavail = availableClasses(showHidden = 1)
    avail = availableClasses(showHidden = 0)
    if len(avail) == 1:
	(cname, cobject, clogo) = avail[0]
	log.info("%s is only installclass, using it" %(cname,))
	instClass = cobject(flags.expert)
    elif len(allavail) == 1:
	(cname, cobject, clogo) = allavail[0]
	log.info("%s is only installclass, using it" %(cname,))
	instClass = cobject(flags.expert)

# this lets install classes force text mode instlls
if instClass.forceTextMode:
    stdoutLog.info(_("Install class forcing text mode installation"))
    opts.display_mode = 't'

#
# find out what video hardware is available to run installer 
#

# XXX kind of hacky - need to remember if we're running on an existing
#                     X display later to avoid some initilization steps
if os.environ.has_key('DISPLAY') and opts.display_mode == 'g':
    x_already_set = 1
else:
    x_already_set = 0

if not opts.isHeadless:
    #
    # Probe what is available for X and setup a hardware state
    #
    # try to probe interesting hw
    import rhpxl.xserver as xserver
    skipddcprobe = (opts.skipddc or (x_already_set and flags.test))
    skipmouseprobe = not (not os.environ.has_key('DISPLAY') or flags.setupFilesystems)

    (videohw, monitorhw, mousehw) = xserver.probeHW(skipDDCProbe=skipddcprobe,
						    skipMouseProbe=skipmouseprobe,
                                                    forceVesa=opts.forcevesa)
    # if the len(videocards) is zero, then let's assume we're isHeadless
    if len(videohw.videocards) == 0:
	stdoutLog.info (_("No video hardware found, assuming headless"))
	videohw = None
	monitorhw = None
	mousehw = None
	opts.isHeadless = 1
    else:
	# setup a X hw state for use later with configuration.  
	try:
	    xcfg = xhwstate.XF86HardwareState(defcard=videohw,
					      defmon=monitorhw)
	except Exception, e:
	    stdoutLog.error (_("Unable to instantiate a X hardware state object."))
	    xcfg = None
else:
    videohw = None
    monitorhw = None
    mousehw = None
    xcfg = None

# keyboard
kbd = keyboard.Keyboard()
if opts.keymap:
    kbd.set(opts.keymap)

#
# delay to let use see status of attempt to probe hw 
#
time.sleep(3)


#
# now determine if we're going to run in GUI or TUI mode
#
# if no X server, we have to use text mode
if not (flags.test or flags.rootpath) and (rhpl.getArch() != "s390" and not os.access("/mnt/runtime/usr/bin/Xorg", os.X_OK)):
     stdoutLog.warning(_("Graphical installation not available...  "
			 "Starting text mode."))
     time.sleep(2)
     opts.display_mode = 't'

if opts.isHeadless: # s390/iSeries checks
    if opts.display_mode == 'g' and not (os.environ.has_key('DISPLAY') or
				         flags.usevnc):
	stdoutLog.warning(_("DISPLAY variable not set. Starting text mode!"))
	opts.display_mode = 't'
	graphical_failed = 1
	time.sleep(2)

# if DISPLAY not set either vnc server failed to start or we're not
# running on a redirected X display, so start local X server
if opts.display_mode == 'g' and not os.environ.has_key('DISPLAY') and not flags.usevnc:
    if iutil.getPPCMachine() == "PMac":
	opts.runres = xhwstate.get_valid_resolution(videohw, monitorhw, opts.runres,
					       runres_override, onPMac=True)
    else:
	opts.runres = xhwstate.get_valid_resolution(videohw, monitorhw, opts.runres,
					       runres_override)

    # make sure we can write log to ramfs
    if os.access("/tmp/ramfs", os.W_OK):
	xlogfile = "/tmp/ramfs/X.log"
    else:
	xlogfile = None

    xsetup_failed = False
    try:
	xcfg = xserver.startX(opts.runres, videohw, monitorhw, mousehw, kbd,
			      logfile = xlogfile,
			      xStartedCB = doStartupX11Actions,
			      xQuitCB = doShutdownX11Actions, useFB = opts.useFBX)
    except RuntimeError:
	xsetup_failed = True

    if xsetup_failed:
	stdoutLog.warning(" X startup failed, falling back to text mode")
	opts.display_mode = 't'
	graphical_failed = 1
	time.sleep(2)

if opts.display_mode == 't' and graphical_failed and not opts.ksfile:
    ret = vnc.askVncWindow()
    if ret != -1:
	opts.display_mode = 'g'
	flags.usevnc = 1
	if ret is not None:
	    vncpassword = ret

# if they want us to use VNC do that now
if opts.display_mode == 'g' and flags.usevnc:
    pidfile = "/tmp/vncshell.pid"

    def addpid(pidnum):
	pf = open(pidfile, "a")
	pf.write("%s\n" %(pidnum))
	pf.close()

    def removepid(pidnum):
	pf = open(pidfile, "r")
	pidlist = pf.readlines()
	pf.close()

	pf = open(pidfile, "w")
	for pid in pidlist:
	    if not int(pid) == pidnum:
	        pf.write("%s" %(pid))
	pf.close()

    # dont run vncpassword if in test mode
    if flags.test:
	vncpassword = ""
	
    startVNCServer(vncpassword=vncpassword,
		   vncconnecthost=vncconnecthost,
		   vncconnectport=vncconnectport)

    child = os.fork()
    if child == 0:
	def conthandler(signum, frame):
	    print "\n"

	signal.signal(signal.SIGCONT, conthandler)

	# wait for parent to write pid (parent will send SIGCONT)
	signal.pause()

	while 1:
	    print _("Press <enter> for a shell")
	    sys.stdin.readline()

	    shpid = os.fork()
	    if shpid == 0:
		for p in ('/mnt/source/RHupdates/pyrc.py', \
			'/tmp/updates/pyrc.py', \
			'/usr/lib/anaconda-runtime/pyrc.py'):
		    if os.access(p, os.R_OK|os.X_OK):
			os.environ['PYTHONSTARTUP'] = p
			break
		os.execv("/bin/sh", ["/bin/sh"])
	    else:
	        addpid(shpid)
	        os.waitpid(shpid, 0)
	        removepid(shpid)
    else:
	addpid(child)
	os.kill(child, signal.SIGCONT)


# setup links required for all install types
for i in ( "services", "protocol", "nsswitch.conf", "joe", "selinux"):
    try:
	os.symlink ("../mnt/runtime/etc/" + i, "/etc/" + i)
    except:
	pass

#
# setup links required by graphical mode if installing and verify display mode
#
if (opts.display_mode == 'g'):
    stdoutLog.info (_("Starting graphical installation..."))
    if not flags.test and flags.setupFilesystems:
	for i in ( "imrc", "im_palette.pal", "gtk-2.0", "pango", "fonts",
		   "fb.modes"):
	    try:
		if os.path.exists("/mnt/runtime/etc/%s" %(i,)):
		    os.symlink ("../mnt/runtime/etc/" + i, "/etc/" + i)
	    except:
		pass

    try:
        from gui import InstallInterface
    except Exception, e:
        stdoutLog.error("Exception starting GUI installer: %s" %(e,))
        if flags.test:
            sys.exit(1)
        # if we're not going to really go into GUI mode, we need to get
        # back to vc1 where the text install is going to pop up.
        if not x_already_set:
            isys.vtActivate (1)
        stdoutLog.warning("GUI installer startup failed, falling back to text mode.")
        opts.display_mode = 't'
        if 'DISPLAY' in os.environ.keys():
            del os.environ['DISPLAY']
        time.sleep(2)

if (opts.display_mode == 't'):
    from text import InstallInterface

if (opts.display_mode == 'c'):
    from cmdline import InstallInterface

if opts.display_mode == "t":
    if not os.environ.has_key("LANG"):
        os.environ["LANG"] = "en_US.UTF-8"

# go ahead and set up the interface
intf = InstallInterface ()

# imports after setting up the path
if opts.method:
    if opts.method.startswith('cdrom://'):
	from image import CdromInstallMethod
	methodobj = CdromInstallMethod(opts.method, opts.rootPath, intf)
    elif opts.method.startswith('nfs:/'):
	from image import NfsInstallMethod
	methodobj = NfsInstallMethod(opts.method, opts.rootPath, intf)
    elif opts.method.startswith('nfsiso:/'):
	from image import NfsIsoInstallMethod
	methodobj = NfsIsoInstallMethod(opts.method, opts.rootPath, intf)
    elif opts.method.startswith('ftp://') or opts.method.startswith('http://'):
	from urlinstall import UrlInstallMethod
	methodobj = UrlInstallMethod(opts.method, opts.rootPath, intf)
    elif opts.method.startswith('hd://'):
        from harddrive import HardDriveInstallMethod
        methodobj = HardDriveInstallMethod(opts.method, opts.rootPath, intf)
    else:
        intf.messageWindow(_("Unknown install method"),
                           _("You have specified an install method "
                             "which isn't supported by anaconda."))
	log.critical (_("unknown install method: %s"), opts.method)
	sys.exit(1)

from yuminstall import YumBackend 
backend = YumBackend(methodobj, opts.rootPath)
floppyDevice = floppy.probeFloppyDevice()

# create device nodes for detected devices if we're not running in test mode
if not flags.test and flags.setupFilesystems:
    iutil.makeDriveDeviceNodes()

id = instClass.installDataClass(extraModules, floppyDevice, opts.method, opts.display_mode, backend)

id.x_already_set = x_already_set

if mousehw:
    id.setMouse(mousehw)

if videohw:
    id.setVideoCard(videohw)

if monitorhw:
    id.setMonitor(monitorhw)

#
# not sure what to do here - somehow we didnt detect anything
#
if xcfg is None and not opts.isHeadless:
    try:
	xcfg = xhwstate.XF86HardwareState()
    except Exception, e:
	stdoutLog.error (_("Unable to instantiate a X hardware state object."))
	xcfg = None

if xcfg is not None:
    xsetup = xsetup.XSetup(xcfg)

    # HACK - if user overrides resolution then use it and disable
    #	     choosing a sane default for them
    if runres_override:
	xsetup.imposed_sane_default = 1
	
    id.setXSetup(xsetup)

if kbd:
    id.setKeyboard(kbd)

id.setDisplayMode(opts.display_mode)
instClass.setInstallData(id, intf)

# We need to copy the VNC-related kickstart stuff into the new ksdata
if opts.ksfile is not None:
    instClass.ksdata.vnc = ksdata.vnc

dispatch = dispatch.Dispatcher(intf, id, methodobj, opts.rootPath, backend)

if opts.lang:
    dispatch.skipStep("language", permanent = 1)
    instClass.setLanguage(id, opts.lang)
    instClass.setLanguageDefault(id, opts.lang)

if opts.keymap:
    dispatch.skipStep("keyboard", permanent = 1)
    instClass.setKeyboard(id, opts.keymap)

# Skip the disk options in rootpath mode
if flags.rootpath:
    dispatch.skipStep("partitionobjinit", permanent = 1)
    dispatch.skipStep("parttype", permanent = 1)
    dispatch.skipStep("autopartitionexecute", permanent = 1)
    dispatch.skipStep("partition", permanent = 1)
    dispatch.skipStep("partitiondone", permanent = 1)
    dispatch.skipStep("bootloadersetup", permanent = 1)
    dispatch.skipStep("bootloader", permanent = 1)
    dispatch.skipStep("bootloaderadvanced", permanent = 1)
    dispatch.skipStep("upgbootloader", permanent = 1)
    dispatch.skipStep("instbootloader", permanent = 1)

# set up the headless case
if opts.isHeadless == 1:
    id.setHeadless(opts.isHeadless)
    instClass.setAsHeadless(dispatch, opts.isHeadless)

instClass.setSteps(dispatch)

# comment out the next line to make exceptions non-fatal
sys.excepthook = lambda type, value, tb, dispatch=dispatch, intf=intf: handleException(dispatch, intf, (type, value, tb))

try:
    intf.run(id, dispatch)
except SystemExit, code:
    intf.shutdown()
except:
    handleException(dispatch, intf, sys.exc_info())

if opts.ksfile is not None and instClass.ksdata.reboot["eject"] == True:
    isys.flushDriveDict()
    for drive in isys.cdromList():
        log.info("attempting to eject %s" % drive)
        isys.ejectCdrom(drive)

del intf
